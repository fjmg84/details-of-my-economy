---
// No server-side logic needed for this component
---

<div class="flex flex-col h-full">
  <!-- Quick Report Buttons -->
  <div class="p-6 border-b border-gray-200">
    <p class="text-sm font-semibold text-gray-700 mb-3">Reportes rápidos:</p>
    <div class="flex flex-wrap gap-2">
      <button
        id="report-summary"
        class="px-4 py-2 bg-blue-50 text-blue-700 rounded-lg text-sm font-medium hover:bg-blue-100 transition-colors"
      >
        Resumen General
      </button>
      <button
        id="report-expenses"
        class="px-4 py-2 bg-red-50 text-red-700 rounded-lg text-sm font-medium hover:bg-red-100 transition-colors"
      >
        Análisis de Gastos
      </button>
      <button
        id="report-income"
        class="px-4 py-2 bg-green-50 text-green-700 rounded-lg text-sm font-medium hover:bg-green-100 transition-colors"
      >
        Análisis de Ingresos
      </button>
      <button
        id="report-categories"
        class="px-4 py-2 bg-purple-50 text-purple-700 rounded-lg text-sm font-medium hover:bg-purple-100 transition-colors"
      >
        Por Categorías
      </button>
      <button
        id="report-trends"
        class="px-4 py-2 bg-yellow-50 text-yellow-700 rounded-lg text-sm font-medium hover:bg-yellow-100 transition-colors"
      >
        Tendencias
      </button>
    </div>
  </div>

  <!-- Messages Container -->
  <div id="chat-messages" class="flex-1 overflow-y-auto p-6 bg-gray-50">
    <div class="flex items-start gap-3 mb-4">
      <div
        class="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center flex-shrink-0"
      >
        <svg
          class="w-5 h-5 text-blue-600"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
          ></path>
        </svg>
      </div>
      <div class="flex-1">
        <div
          class="bg-white rounded-lg p-4 shadow-sm border border-gray-200 max-w-4xl"
        >
          <p class="text-sm text-gray-700">
            ¡Hola! Soy tu asistente financiero. Puedes preguntarme sobre tus
            transacciones o solicitar un reporte usando los botones de arriba.
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- Input Area -->
  <div class="p-6 bg-white border-t border-gray-200">
    <div class="flex gap-3">
      <input
        type="text"
        id="user-question"
        placeholder="Pregúntame sobre tus finanzas..."
        class="flex-1 px-4 py-2.5 bg-white border border-gray-300 rounded-lg text-sm text-gray-900 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
      />
      <button
        id="send-question"
        class="px-4 py-2.5 bg-blue-600 text-white rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
      >
        <svg
          class="w-5 h-5"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
        </svg>
      </button>
    </div>
  </div>
</div>

<!-- Loading Indicator -->
<div id="loading-indicator" class="hidden mt-4 text-center">
  <div class="inline-flex items-center px-4 py-2 bg-blue-50 rounded-lg">
    <svg
      class="animate-spin -ml-1 mr-3 h-5 w-5 text-blue-600"
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
    >
      <circle
        class="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        stroke-width="4"></circle>
      <path
        class="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      ></path>
    </svg>
    <span class="text-blue-800">Analizando...</span>
  </div>
</div>

<script>
  import {
    generateFinancialReportStream,
    askAboutTransactionsStream,
    type ChatMessage,
  } from "../utils/ollama/fnOllama";
  import {
    getChatHistory,
    saveChatMessage,
    cleanExpiredMessages,
  } from "../utils/chatStorage";

  // DOM Elements
  const chatMessages = document.getElementById("chat-messages");
  const userQuestionInput = document.getElementById(
    "user-question",
  ) as HTMLInputElement;
  const sendButton = document.getElementById("send-question");
  const loadingIndicator = document.getElementById("loading-indicator");

  // Report buttons
  const reportButtons = {
    "report-summary": "summary",
    "report-expenses": "expenses",
    "report-income": "income",
    "report-categories": "categories",
    "report-trends": "trends",
  };

  function addAvatar(isUser: boolean = false) {
    // Avatar
    const avatar = document.createElement("div");
    avatar.className = `w-8 h-8 rounded-full flex items-center justify-center flex-shrink-0 ${
      isUser ? "bg-gray-200" : "bg-blue-100"
    }`;

    if (isUser) {
      avatar.innerHTML = `<svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
      </svg>`;
    } else {
      avatar.innerHTML = `<svg class="w-5 h-5 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
      </svg>`;
    }
    return avatar;
  }

  // Display message on chat (without saving)
  function displayMessageInChat(
    content: string,
    isUser: boolean = false,
  ): HTMLElement {
    const messageDiv = document.createElement("div");
    messageDiv.className = `flex items-start gap-3 mb-4 ${isUser ? "flex-row-reverse" : ""}`;

    // Message bubble
    const messageBubble = document.createElement("div");
    messageBubble.className = `flex-1 ${
      isUser
        ? "bg-blue-600 text-white"
        : "bg-white border border-gray-200 text-gray-700"
    } rounded-lg p-4 shadow-sm max-w-4xl`;

    messageBubble.innerHTML = content.replace(/\n/g, "<br>");

    messageDiv.appendChild(addAvatar(isUser));
    messageDiv.appendChild(messageBubble);

    if (chatMessages) {
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    return messageBubble;
  }

  // Add message to chat AND save to history
  function addMessage(content: string, isUser: boolean = false): HTMLElement {
    const bubble = displayMessageInChat(content, isUser);
    // Guardar solo los mensajes nuevos
    saveChatMessage(isUser ? "user" : "assistant", content);
    return bubble;
  }

  // Add streaming message (returns the bubble element for updates)
  function addStreamingMessage(): HTMLElement {
    const messageDiv = document.createElement("div");
    messageDiv.className = "mb-3 text-left flex items-start gap-3";

    const messageBubble = document.createElement("div");
    messageBubble.className =
      "inline-block max-w-4xl px-4 py-2 rounded-lg bg-white border border-gray-200 text-gray-800";
    messageBubble.innerHTML =
      '<span class="text-gray-400">Escribiendo...</span>';

    messageDiv.appendChild(addAvatar());
    messageDiv.appendChild(messageBubble);

    if (chatMessages) {
      chatMessages.appendChild(messageDiv);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    return messageBubble;
  }

  // Update streaming message content
  function updateStreamingMessage(bubble: HTMLElement, content: string) {
    bubble.innerHTML = content.replace(/\n/g, "<br>");
    if (chatMessages) {
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
  }

  // Show/hide loading
  function setLoading(loading: boolean) {
    if (loadingIndicator) {
      loadingIndicator.classList.toggle("hidden", !loading);
    }
    if (sendButton) {
      (sendButton as HTMLButtonElement).disabled = loading;
    }
  }

  // Handle user question with streaming
  async function handleUserQuestion(question: string) {
    if (!question.trim()) return;

    addMessage(question, true);
    setLoading(true);

    const streamingBubble = addStreamingMessage();
    let accumulatedContent = "";

    try {
      // Obtener el historial de chat sin el mensaje actual del usuario
      const previousMessages = getChatHistory().slice(0, -1) as ChatMessage[];

      await askAboutTransactionsStream(
        question,
        (chunk: string) => {
          accumulatedContent += chunk;
          updateStreamingMessage(streamingBubble, accumulatedContent);
        },
        previousMessages,
      );
      // Guardar el mensaje del asistente después de completar
      saveChatMessage("assistant", accumulatedContent);
    } catch (error) {
      console.error("Error asking question:", error);
      updateStreamingMessage(
        streamingBubble,
        "Lo siento, ocurrió un error al procesar tu pregunta. Asegúrate de que Ollama esté ejecutándose.",
      );
    } finally {
      setLoading(false);
    }
  }

  // Handle report generation with streaming
  async function handleReportGeneration(reportType: string) {
    const reportNames = {
      summary: "Resumen General",
      expenses: "Análisis de Gastos",
      income: "Análisis de Ingresos",
      categories: "Análisis por Categorías",
      trends: "Análisis de Tendencias",
    };

    const reportName =
      reportNames[reportType as keyof typeof reportNames] || reportType;
    addMessage(`Generar ${reportName}`, true);
    setLoading(true);

    const streamingBubble = addStreamingMessage();
    let accumulatedContent = "";

    try {
      // Obtener el historial de chat sin el mensaje actual del usuario
      const previousMessages = getChatHistory().slice(0, -1) as ChatMessage[];

      await generateFinancialReportStream(
        reportType as any,
        (chunk: string) => {
          accumulatedContent += chunk;
          updateStreamingMessage(streamingBubble, accumulatedContent);
        },
        previousMessages,
      );
      // Guardar el mensaje del asistente después de completar
      saveChatMessage("assistant", accumulatedContent);
    } catch (error) {
      console.error("Error generating report:", error);
      updateStreamingMessage(
        streamingBubble,
        "Lo siento, ocurrió un error al generar el reporte. Asegúrate de que Ollama esté ejecutándose.",
      );
    } finally {
      setLoading(false);
    }
  }

  // Event listeners
  if (sendButton) {
    sendButton.addEventListener("click", () => {
      const question = userQuestionInput?.value || "";
      if (question.trim()) {
        handleUserQuestion(question);
        userQuestionInput.value = "";
      }
    });
  }

  if (userQuestionInput) {
    userQuestionInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        const question = userQuestionInput.value || "";
        if (question.trim()) {
          handleUserQuestion(question);
          userQuestionInput.value = "";
        }
      }
    });
  }

  // Report button listeners
  Object.entries(reportButtons).forEach(([buttonId, reportType]) => {
    const button = document.getElementById(buttonId);
    if (button) {
      button.addEventListener("click", () => {
        handleReportGeneration(reportType);
      });
    }
  });

  /**
   * Inicializar el historial de chat
   * Limpia mensajes expirados y carga el historial anterior
   */
  function initializeChatHistory() {
    // Limpiar mensajes expirados
    cleanExpiredMessages();

    // Obtener historial válido
    const chatHistory = getChatHistory();

    // Si hay historial previo, cargar los mensajes
    if (chatHistory.length > 0) {
      // Limpiar el mensaje inicial de bienvenida
      if (chatMessages) {
        chatMessages.innerHTML = "";
      }

      // Cargar cada mensaje del historial SIN guardar nuevamente
      chatHistory.forEach((message) => {
        displayMessageInChat(message.content, message.role === "user");
      });
    }
  }

  // Inicializar el chat al cargar la página
  initializeChatHistory();
</script>
